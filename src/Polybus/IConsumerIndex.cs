namespace Polybus
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Linq.Expressions;
    using System.Reflection;
    using System.Threading;
    using Google.Protobuf;
    using Google.Protobuf.Reflection;

    public interface IConsumerIndex : IReadOnlyDictionary<string, ConsumerDescriptor>
    {
        protected static void InitializeIndex(IEnumerable<IEventConsumer> consumers, Action<ConsumerDescriptor> add)
        {
            foreach (var consumer in consumers)
            {
                var descriptors = CreateConsumerDescriptors(consumer).ToList();

                if (descriptors.Count == 0)
                {
                    throw new ArgumentException($"{consumer.GetType()} is not a valid consumer.", nameof(consumers));
                }

                foreach (var descriptor in descriptors)
                {
                    add(descriptor);
                }
            }
        }

        private static IEnumerable<ConsumerDescriptor> CreateConsumerDescriptors(IEventConsumer consumer)
        {
            var type = consumer.GetType();

            foreach (var @interface in type.GetInterfaces())
            {
                // Determine if it is IEventConsumer<>.
                if (!@interface.IsGenericType || @interface.GetGenericTypeDefinition() != typeof(IEventConsumer<>))
                {
                    continue;
                }

                var @event = @interface.GetGenericArguments().Single();

                // Get event descriptor and parser.
                var descriptor = @event.GetProperty("Descriptor");
                var parser = @event.GetProperty("Parser");

                if (descriptor == null || parser == null)
                {
                    throw new ArgumentException(
                        $"{type} implements {typeof(IEventConsumer<>)} with the {@event} that does not generated by 'protoc'.",
                        nameof(consumer));
                }

                // Get consumer methods.
                var map = type.GetInterfaceMap(@interface);
                MethodInfo? consumeEvent = null;

                for (var i = 0; i < map.InterfaceMethods.Length; i++)
                {
                    switch (map.InterfaceMethods[i].Name)
                    {
                        case nameof(IEventConsumer<IMessage>.ConsumeEventAsync):
                            consumeEvent = map.TargetMethods[i];
                            break;
                    }
                }

                if (consumeEvent == null)
                {
                    // This should never happened.
                    throw new ArgumentException(
                        $"{type} does not implemented {typeof(IEventConsumer<>)}.{nameof(IEventConsumer<IMessage>.ConsumeEventAsync)}.",
                        nameof(consumer));
                }

                // Compile wrapper for ConsumeEventAsync.
                yield return new ConsumerDescriptor(
                    consumer,
                    (MessageDescriptor)descriptor.GetValue(null),
                    (MessageParser)parser.GetValue(null),
                    CreateConsumeExecutor(consumer, @event, consumeEvent));
            }
        }

        private static ConsumeExecutor CreateConsumeExecutor(
            IEventConsumer consumer,
            Type @event,
            MethodInfo consumeEvent)
        {
            // Dynamically create the following lambda:
            // (arg1, arg2) => ((consumeEvent.DeclaringType)instance).consumeEvent((@event)arg1, arg2)
            var arg1 = Expression.Parameter(typeof(object));
            var arg2 = Expression.Parameter(typeof(CancellationToken));
            var instance = Expression.Constant(consumer);

            var body = Expression.Call(
                Expression.Convert(instance, consumeEvent.DeclaringType),
                consumeEvent,
                Expression.Convert(arg1, @event),
                arg2);

            return Expression.Lambda<ConsumeExecutor>(body, arg1, arg2).Compile();
        }
    }
}
